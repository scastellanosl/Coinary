package com.example.coinary.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.coinary.data.FirestoreManager
import com.example.coinary.model.Debt
import com.example.coinary.model.Expense
import com.example.coinary.model.Income
import com.google.firebase.Timestamp
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.util.Date

/**
 * UI State for the Movement Screen.
 * Holds loading status, messages, detected "Ant Expenses", and temporary data
 * for handling insufficient balance scenarios.
 */
data class MovementUiState(
    val isLoading: Boolean = false,
    val successMessage: String? = null,
    val errorMessage: String? = null,
    val antExpenses: List<Expense> = emptyList(),
    val showDebtConfirmation: Boolean = false, // Triggers the "Create Debt?" dialog
    val pendingExpenseData: Expense? = null    // Holds expense details while waiting for user confirmation
)

/**
 * MovementViewModel: Manages the logic for recording Incomes and Expenses.
 * It implements the "Ant Expense" detection algorithm and enforces balance checks,
 * suggesting debt creation if expenses exceed available funds.
 */
class MovementViewModel(
    private val firestoreManager: FirestoreManager = FirestoreManager()
) : ViewModel() {

    private val _uiState = MutableStateFlow(MovementUiState())
    val uiState: StateFlow<MovementUiState> = _uiState.asStateFlow()

    // Local variables to maintain real-time balance context
    private var currentTotalIncome = 0.0
    private var currentTotalExpense = 0.0

    init {
        // 1. Initialize data streams
        loadAntExpenses()
        listenToBalance()
    }

    /**
     * Loads the list of expenses identified as "Ant Expenses" (small, frequent).
     */
    private fun loadAntExpenses() {
        firestoreManager.getAntExpensesRealtime(
            onExpensesLoaded = { list ->
                _uiState.update { it.copy(antExpenses = list) }
            },
            onFailure = { /* Silent failure implementation */ }
        )
    }

    /**
     * Subscribes to real-time income and expense totals to calculate net balance.
     */
    private fun listenToBalance() {
        firestoreManager.getTotalIncomesRealtime(
            onTotalIncomeLoaded = { currentTotalIncome = it },
            onFailure = { }
        )
        firestoreManager.getTotalExpensesRealtime(
            onTotalExpenseLoaded = { currentTotalExpense = it },
            onFailure = { }
        )
    }

    // ========================================================================
    // REGION: INCOME HANDLING
    // ========================================================================

    fun saveIncome(amount: Double, description: String, category: String, date: Date) {
        _uiState.update { it.copy(isLoading = true, successMessage = null, errorMessage = null) }

        viewModelScope.launch {
            val income = Income(
                id = "", // ID generated by Firestore
                amount = amount,
                description = description,
                category = category,
                date = Timestamp(date)
            )

            firestoreManager.addIncome(
                income = income,
                onSuccess = {
                    _uiState.update { it.copy(isLoading = false, successMessage = "Income saved successfully.") }
                },
                onFailure = { e ->
                    _uiState.update { it.copy(isLoading = false, errorMessage = e.message) }
                }
            )
        }
    }

    // ========================================================================
    // REGION: EXPENSE HANDLING (Core Logic)
    // ========================================================================

    /**
     * Public entry point for saving an expense.
     * Checks balance validity before processing.
     */
    fun saveExpense(amount: Double, description: String, category: String, date: Date) {
        processExpenseTransaction(amount, description, category, date)
    }

    /**
     * Internal logic:
     * 1. Checks if the user has enough balance.
     * 2. If Balance < Amount -> Triggers Debt Confirmation Dialog.
     * 3. If Balance >= Amount -> Proceeds to Ant Expense Analysis.
     */
    private fun processExpenseTransaction(amount: Double, description: String, category: String, date: Date) {
        _uiState.update { it.copy(isLoading = true, successMessage = null, errorMessage = null) }

        // Step 1: Verify Balance
        val currentBalance = currentTotalIncome - currentTotalExpense

        if (amount > currentBalance) {
            // ---> STOP: Insufficient funds. Trigger UI Alert.
            val tempExpense = Expense(
                id = "",
                amount = amount,
                description = description,
                category = category,
                date = Timestamp(date),
                isAntExpense = false
            )

            _uiState.update {
                it.copy(
                    isLoading = false,
                    showDebtConfirmation = true,
                    pendingExpenseData = tempExpense
                )
            }
        } else {
            // ---> OK: Funds available. Proceed to analysis.
            analyzeAndSaveExpense(amount, description, category, date)
        }
    }

    /**
     * Analyzes if the expense fits the "Ant Expense" pattern (Low cost + High frequency)
     * and saves it to Firestore.
     */
    private fun analyzeAndSaveExpense(amount: Double, description: String, category: String, date: Date) {
        viewModelScope.launch {
            // Step 2: Check Frequency
            firestoreManager.getRecentExpensesCount(
                category = category,
                onResult = { pastFrequency ->

                    // Ant Expense Criteria: Amount <= 9000 AND Frequency >= 2
                    val maxAmountForAnt = 9000.0
                    val isAnt = (amount <= maxAmountForAnt && pastFrequency >= 2)

                    // Step 3: Save to Firestore
                    val expense = Expense(
                        id = "",
                        amount = amount,
                        description = description,
                        category = category,
                        date = Timestamp(date),
                        isAntExpense = isAnt
                    )

                    firestoreManager.addExpense(
                        expense = expense,
                        onSuccess = {
                            val msg = if (isAnt) "⚠️ Ant habit detected ($category)" else "Expense saved."
                            _uiState.update { it.copy(isLoading = false, successMessage = msg) }
                        },
                        onFailure = { e ->
                            _uiState.update { it.copy(isLoading = false, errorMessage = e.message) }
                        }
                    )
                },
                onFailure = {
                    // Fallback logic for offline scenarios
                    saveExpenseFallback(amount, description, category, date)
                }
            )
        }
    }

    /**
     * Fallback method to save an expense without Ant analysis (e.g., network error).
     */
    private fun saveExpenseFallback(amount: Double, description: String, category: String, date: Date) {
        val expense = Expense(
            id = "",
            amount = amount,
            description = description,
            category = category,
            date = Timestamp(date),
            isAntExpense = false
        )

        firestoreManager.addExpense(
            expense = expense,
            onSuccess = {
                _uiState.update { it.copy(isLoading = false, successMessage = "Expense saved (Offline mode).") }
            },
            onFailure = { e ->
                _uiState.update { it.copy(isLoading = false, errorMessage = e.message) }
            }
        )
    }

    // ========================================================================
    // REGION: DEBT ALERT HANDLING
    // ========================================================================

    /**
     * Confirms the creation of a Debt record when the user accepts the
     * "Insufficient Balance" warning.
     */
    fun confirmDebtCreation() {
        val temp = _uiState.value.pendingExpenseData ?: return
        _uiState.update { it.copy(isLoading = true, showDebtConfirmation = false) }

        val newDebt = Debt(
            id = "",
            amount = temp.amount,
            description = temp.description,
            creditor = "Personal Budget", // Default creditor for auto-generated debts
            dueDate = Timestamp.now(),
            isPaid = false,
            amountPaid = 0.0
        )

        firestoreManager.addDebt(
            debt = newDebt,
            onSuccess = {
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        successMessage = "A debt has been created automatically.",
                        pendingExpenseData = null
                    )
                }
            },
            onFailure = { e ->
                _uiState.update { it.copy(isLoading = false, errorMessage = e.message) }
            }
        )
    }

    /**
     * Cancels the debt creation process and dismisses the dialog.
     */
    fun cancelDebtCreation() {
        _uiState.update { it.copy(showDebtConfirmation = false, pendingExpenseData = null) }
    }

    /**
     * Clears any success or error messages from the UI state.
     */
    fun resetMessages() {
        _uiState.update { it.copy(successMessage = null, errorMessage = null) }
    }
}